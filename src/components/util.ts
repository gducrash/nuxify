import type { ExtensionSettings, Language, YoutubeCaptionData } from "./types";
import { DICTIONARY, DEFAULT_SETTINGS, LIVE_DUBBING_TYPES } from "./constants";

// used to generate a pseudo-random value for every title
// so that the random thumbnails always match
export function getStringSeed (str: string, max: number) {
    let seed = 0;
    for (let i = 0; i < str.length; i++)
        seed += str.charCodeAt(i);
    seed = seed % max;
    return seed;
}

// observe dom element changes
export function onElement (
    selector: string, 
    callback: (elem: HTMLElement, type: string, ...args: any[]) => void, 
    config: MutationObserverInit, 
    targetNode: HTMLElement = document.body
) {
    const observer = new MutationObserver((mutationsList) => {
        for (let mutation of mutationsList) {
            if (mutation.type === 'childList') {
                mutation.addedNodes.forEach(node => {
                    const elem = node as HTMLElement;
                    if (elem.nodeType === 1 && elem.matches(selector)) {
                        callback(elem, 'added');
                    }
                });
            } else if (mutation.type === 'attributes') {
                const elem = mutation.target as HTMLElement;
                if (elem.matches(selector)) {
                    //// console.log(mutation.attributeName);
                    callback(elem, 'attributes', mutation.attributeName);
                }
            }
        }
    });

    observer.observe(targetNode, config);
    return observer;
}

export function getPageLanguage (): Language {
    const lang = document.documentElement.lang.split('-')[0].toLowerCase();
    if (Object.keys(DICTIONARY).includes(lang))
        return lang as Language;
    return 'en';
}


export function unicodeToChar(text: string) {
    return text.replace(/\\u[\dA-F]{4}/gi, 
        function (match) {
            return String.fromCharCode(parseInt(match.replace(/\\u/g, ''), 16));
        });
 }
 
export async function getVideoLiveCaptions (videoId: string, asrOnly: boolean = false) {
    // fetch the youtube video page
    const videoPageRes = await fetch(`https://www.youtube.com/watch?v=${videoId}`);
    const videoPageText = await videoPageRes.text();

    // get query data for all caption tracks
    const trackQueries = videoPageText.split("timedtext?").slice(1).map(t => unicodeToChar(t.split('"')[0]));
    const tracks: YoutubeCaptionData[] = [];

    // for each caption track
    for (const trackQuery of trackQueries) {
        // if asrOnly flag is true, skip all tracks that are not auto-generated by youtube
        const params = Object.fromEntries(new URLSearchParams(trackQuery));
        if (asrOnly && params.kind != 'asr') continue;
        
        // fetch caption track json data
        params.fmt = "json3";
        const url = 'https://www.youtube.com/api/timedtext?' + new URLSearchParams(params).toString();
        const captionsRes = await fetch(url);
        const track: YoutubeCaptionData = await captionsRes.json();

        tracks.push(track);
    };

    return tracks;
}

export function sanitizeCaptionSegment (seg: string) {
    return seg.trim().toLowerCase();
}

export function getLiveDubbingType (seg: string): keyof typeof LIVE_DUBBING_TYPES | undefined {
    const segSanitized = sanitizeCaptionSegment(seg);
    let targetType: string|undefined;
    Object.keys(LIVE_DUBBING_TYPES).forEach(type => {
        if (LIVE_DUBBING_TYPES[type].includes(segSanitized))
            targetType = type;
    });
    return targetType as keyof typeof LIVE_DUBBING_TYPES;
}

export async function updateSettings <K extends keyof ExtensionSettings>(key: K, value: ExtensionSettings[K]) {
    const settings = await getSettings();
    settings[key] = value;
    await browser.storage.sync.set({ settings });
}

export async function getSettingsItem <K extends keyof ExtensionSettings> (key: K): Promise<ExtensionSettings[K]> {
    const settings = await getSettings();
    return settings[key];
}

export async function getSettings (): Promise<ExtensionSettings> {
    const settings = (await browser.storage.sync.get('settings')).settings as ExtensionSettings;
    if (settings)
        Object.keys(DEFAULT_SETTINGS).forEach(key => {
            if (settings[key] === undefined) {
                settings[key] = DEFAULT_SETTINGS[key];
            }
        })

    return settings ?? DEFAULT_SETTINGS;
}
